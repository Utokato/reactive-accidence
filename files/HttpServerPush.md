# 使用 WebSocket 和 SSE 实现 HTTP 服务器推送

> [原文连接](https://www.ibm.com/developerworks/cn/web/wa-http-server-push-with-websocket-sse/index.html)
>
> Web 和移动应用程序的实时数据传输

HTTP 服务器推送也称为 HTTP 流，是一种客户端-服务器通信模式，它将信息从 HTTP 服务器异步发送到客户端，而无需客户端请求。在高度交互的 Web 或移动应用程序中，一个或多个客户端需要连续不断地从服务器接收信息，服务器推送架构对这类应用程序特别有效。 WebSocket 和 SSE（服务器发送的事件），它们是实现 HTTP 服务器推送的两种技术。

我首先将概述两种解决方案之间的技术差异，以及如何在 Web 架构中实现每种解决方案。我将通过一个示例应用程序，向您展示如何设置一个 SSE 实现，然后介绍一个类似的 WebSocket 实现。最后，我将比较两种技术，并提出我关于在不同类型 Web 或移动应用程序中使用它们的结论。

请注意，本文要求熟悉 HTTP 服务器推送的语言和概念。

## 请求-响应的局限性

网络上的客户端-服务器通信在过去曾是一种请求-响应模型，要求客户端（比如 Web 浏览器）向服务器请求资源。服务器通过发送所请求的资源来响应客户端请求。如果资源不可用，或者客户端没有权限访问它，那么服务器会发送一条错误消息。在请求-响应架构中，服务器绝不能向客户端发送未经请求的消息。

随着 Web 应用程序变得更强大和更具交互性，请求-响应模型的局限性也开始显现出来。需要更频繁更新的客户端应用程序被要求更频繁地发送 `GET` 请求。这种技术称为*轮询*，在高峰期间，这可能会使服务器不堪重负，并导致性能问题。该技术效率低下，因为客户端发送的许多请求都没有返回更新。此外，客户端只能按指定间隔进行轮询，这可能减缓客户端的响应速度。

HTTP 服务器推送技术的出现，就是为了解决与频繁轮询相关的性能问题和其他局限。尤其是对于交互式 Web 应用程序，比如游戏和屏幕共享服务，Web 服务器能更高效地在新数据可用时向客户端发送更新。

### 比较 WebSocket 与 SSE

WebSocket 和 SSE 都是传统请求-响应 Web 架构的替代方案，但它们不是完全冲突的技术。WebSocket 架构在客户端与服务器之间打开一个Socket，用于实现全双工（双向）通信。无需发送 `GET` 消息并等待服务器响应，客户端只需监听该Socket，接收服务器更新，并使用收到的数据来发起或支持各种交互。客户端也可以使用Socket与服务器通信，例如在成功收到更新时发送 `ACK` （acknowledge） 消息。

SSE 是一种更简单的标准，是作为 HTML5 的扩展而开发的。尽管 SSE 支持从服务器向客户端发送异步消息，但客户端无法向服务器发送消息。对于客户端只需接收从服务器传入的更新的应用程序，SSE 的半双工通信模型最适合。与 WebSocket 相比，SSE 的一个优势是它是基于 HTTP 而运行的，不需要其他组件。

### 浏览器支持

在比较 HTTP 协议时，浏览器支持是一个必要的考虑因素。所有现代浏览器都支持 [WebSocket](http://caniuse.com/#feat=WebSockets) 协议，包括移动浏览器，但并不是所有的浏览器都支持 SSE。对于必须在所有浏览器中运行的应用程序，WebSocket 目前是更好的选择。

### 开发工作量

在比较协议时，尤其是 WebSocket 和 SSE 等较新的协议，工作量是要考虑的另一个因素。这里的 “工作量” 指的是代码行，或者您要花多少时间为使用给定协议的应用程序编写代码。对于具有严格的时间限制或开发预算的项目，这个指标特别重要。

实现 SSE 的工作量比 WebSocket 要少得多。它适合任何使用 HTML5 编写的应用程序，主要负责在从服务器发送到客户端的消息中添加一个 HTTP 标头。如果给定了正确标头，客户端就会自动将消息识别为服务器发送的事件。不同于 WebSocket，SSE 不需要在服务器与客户端之间建立或维护套接字连接。

WebSocket 协议要求配置一个服务器端套接字来监听客户端连接。客户端自动打开一个与服务器的套接字并等待消息，消息可以异步发送。每个应用程序都可以定义自己的消息格式、持久连接（脉动信号，或者称为心跳信号）策略等。

## 开发 SSE 应用程序

在 Java 中，通过 Spring boot 可以迅速搭建一个 Web 应用，由于 SSE 仅仅需要修改一个 HTTP 的响应头信息，这些操作在  Spring boot 是可以很简单地完成。下面模拟一个时钟程序，即前端访问指定地 URL，后端返回当前时间的字符串，由于响应头信息中明确指定为`"application/stream+json"`，即开启了半双工的 SSE，也就是当页面第一次访问到该 URL 时，后端会源源不断地推送数据到前端页面。

```java
@RestController
@RequestMapping("/datetime")
public class DatetimeController {
    /**
     * WebSocket 与 SSE
     * 全双工 与 半双工
     * 
     * Flux 是响应式框架 Reactor 中的核心对象，有兴趣可以了解一下
     * 
     * @return 当前时间的字符串
     */
    @GetMapping(value = "/now", produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
    public Flux<String> now() {
        return Flux.interval(Duration.ofMillis(1000)).map(
                i -> LocalDateTime.now()
            		.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")) + "\n\n"
        );
    }
}
```



## 开发 WebSocket 应用程序







## 结束语

对于只需要能向客户端传输异步服务器消息的 Web 应用程序，服务器发送的事件是一个优雅且简单的解决方案。作为半双工 HTTP 解决方案，SSE 不允许客户端向服务器回传消息。此外，在编写本文时，所有 Microsoft 浏览器都不支持 SSE。此限制是否是致命弱点，取决于应用程序的目标受众。

WebSocket 更复杂且要求更高，但全双工 TCP 连接使它适用于更广泛的应用场景。WebSocket 受大多数现代 Web 框架支持，而且兼容所有主要的 Web 和移动浏览器。尽管没有演示，但可以使用类似 Tornado 这样的服务器框架，它有助于快速配置推送服务器，而无需从头编写服务器代码。

SSE 是一个更简单且更快的解决方案，但它是不可扩展的。如果 Web 应用程序的需求发生了改变（例如，如果您认为前端应与后端交互），则需要使用 WebSocket 重构应用程序。WebSocket 需要做更多的前期工作，但它是一种更灵活的、可扩展的框架。它更适合会不断添加新功能的复杂应用程序。